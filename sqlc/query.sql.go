// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"
)

const createCategorie = `-- name: CreateCategorie :execresult
INSERT INTO categorie (
  category_name, description
) VALUES (
  ?, ?
)
`

type CreateCategorieParams struct {
	CategoryName sql.NullString
	Description  sql.NullString
}

func (q *Queries) CreateCategorie(ctx context.Context, arg CreateCategorieParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createCategorie, arg.CategoryName, arg.Description)
}

const createCustomer = `-- name: CreateCustomer :execresult
INSERT INTO customer (
  customer_name, contact_name, address, city, postal_code, country
) VALUES (
  ?, ?, ?, ?, ?, ?
)
`

type CreateCustomerParams struct {
	CustomerName sql.NullString
	ContactName  sql.NullString
	Address      sql.NullString
	City         sql.NullString
	PostalCode   sql.NullString
	Country      sql.NullString
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createCustomer,
		arg.CustomerName,
		arg.ContactName,
		arg.Address,
		arg.City,
		arg.PostalCode,
		arg.Country,
	)
}

const createEmployee = `-- name: CreateEmployee :execresult
INSERT INTO employee (
  last_name, first_name, birth_date, photo, notes
) VALUES (
  ?, ?, ?, ?, ?
)
`

type CreateEmployeeParams struct {
	LastName  sql.NullString
	FirstName sql.NullString
	BirthDate sql.NullString
	Photo     sql.NullString
	Notes     sql.NullString
}

func (q *Queries) CreateEmployee(ctx context.Context, arg CreateEmployeeParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createEmployee,
		arg.LastName,
		arg.FirstName,
		arg.BirthDate,
		arg.Photo,
		arg.Notes,
	)
}

const createOrder = `-- name: CreateOrder :execresult
INSERT INTO orders (
  id, customer_id, employee_id, shipper_id, order_date
) VALUES (
  ?, ?, ?, ?, ?
)
`

type CreateOrderParams struct {
	ID         int32
	CustomerID sql.NullInt32
	EmployeeID sql.NullInt32
	ShipperID  sql.NullInt32
	OrderDate  sql.NullString
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createOrder,
		arg.ID,
		arg.CustomerID,
		arg.EmployeeID,
		arg.ShipperID,
		arg.OrderDate,
	)
}

const createOrderDetail = `-- name: CreateOrderDetail :execresult
INSERT INTO order_detail (
  order_id, product_id, quantity
) VALUES (
  ?, ?, ?
)
`

type CreateOrderDetailParams struct {
	OrderID   sql.NullInt32
	ProductID sql.NullInt32
	Quantity  sql.NullInt32
}

func (q *Queries) CreateOrderDetail(ctx context.Context, arg CreateOrderDetailParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createOrderDetail, arg.OrderID, arg.ProductID, arg.Quantity)
}

const createProduct = `-- name: CreateProduct :execresult
INSERT INTO product (
  product_name, supplier_id, category_id, unit, price
) VALUES (
  ?, ?, ?, ?, ?
)
`

type CreateProductParams struct {
	ProductName sql.NullString
	SupplierID  sql.NullInt32
	CategoryID  sql.NullInt32
	Unit        sql.NullString
	Price       sql.NullFloat64
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createProduct,
		arg.ProductName,
		arg.SupplierID,
		arg.CategoryID,
		arg.Unit,
		arg.Price,
	)
}

const createShipper = `-- name: CreateShipper :execresult
INSERT INTO shipper (
  shipper_name, phone
) VALUES (
  ?, ?
)
`

type CreateShipperParams struct {
	ShipperName sql.NullString
	Phone       sql.NullString
}

func (q *Queries) CreateShipper(ctx context.Context, arg CreateShipperParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createShipper, arg.ShipperName, arg.Phone)
}

const createSupplier = `-- name: CreateSupplier :execresult
INSERT INTO supplier (
  supplier_name, contact_name, address, city, postal_code, country, phone
) VALUES (
  ?, ?, ?, ?, ?, ?, ?
)
`

type CreateSupplierParams struct {
	SupplierName sql.NullString
	ContactName  sql.NullString
	Address      sql.NullString
	City         sql.NullString
	PostalCode   sql.NullString
	Country      sql.NullString
	Phone        sql.NullString
}

func (q *Queries) CreateSupplier(ctx context.Context, arg CreateSupplierParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createSupplier,
		arg.SupplierName,
		arg.ContactName,
		arg.Address,
		arg.City,
		arg.PostalCode,
		arg.Country,
		arg.Phone,
	)
}

const deleteCustomer = `-- name: DeleteCustomer :exec
DELETE FROM customer
WHERE id = ?
`

func (q *Queries) DeleteCustomer(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteCustomer, id)
	return err
}

const getCustomer = `-- name: GetCustomer :one
SELECT id, customer_name, contact_name, address, city, postal_code, country, created_at, updated_at, deleted_at FROM customer
WHERE id = ? LIMIT 1
`

func (q *Queries) GetCustomer(ctx context.Context, id int32) (Customer, error) {
	row := q.db.QueryRowContext(ctx, getCustomer, id)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.CustomerName,
		&i.ContactName,
		&i.Address,
		&i.City,
		&i.PostalCode,
		&i.Country,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listCustomer = `-- name: ListCustomer :many
SELECT id, customer_name, contact_name, address, city, postal_code, country, created_at, updated_at, deleted_at FROM customer
ORDER BY customer_name
`

func (q *Queries) ListCustomer(ctx context.Context) ([]Customer, error) {
	rows, err := q.db.QueryContext(ctx, listCustomer)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.CustomerName,
			&i.ContactName,
			&i.Address,
			&i.City,
			&i.PostalCode,
			&i.Country,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ordersAssocaitedWithCustomer = `-- name: OrdersAssocaitedWithCustomer :many
SELECT
    c.id AS customer_id,
    c.customer_name,
    c.contact_name,
    c.address,
    c.city,
    c.postal_code,
    c.country,
    o.id AS order_id,
    o.order_date,
    od.id AS order_detail_id,
    p.product_name,
    od.quantity,
    p.price,
    CAST((od.quantity * p.price) AS FLOAT) AS total_amount
FROM
    customer c
LEFT JOIN
    orders o ON c.id = o.customer_id
LEFT JOIN
    order_detail od ON o.id = od.order_id
LEFT JOIN
    product p ON od.product_id = p.id
WHERE
    c.id = ?
`

type OrdersAssocaitedWithCustomerRow struct {
	CustomerID    int32
	CustomerName  sql.NullString
	ContactName   sql.NullString
	Address       sql.NullString
	City          sql.NullString
	PostalCode    sql.NullString
	Country       sql.NullString
	OrderID       sql.NullInt32
	OrderDate     sql.NullString
	OrderDetailID sql.NullInt32
	ProductName   sql.NullString
	Quantity      sql.NullInt32
	Price         sql.NullFloat64
	TotalAmount   float64
}

func (q *Queries) OrdersAssocaitedWithCustomer(ctx context.Context, id int32) ([]OrdersAssocaitedWithCustomerRow, error) {
	rows, err := q.db.QueryContext(ctx, ordersAssocaitedWithCustomer, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrdersAssocaitedWithCustomerRow
	for rows.Next() {
		var i OrdersAssocaitedWithCustomerRow
		if err := rows.Scan(
			&i.CustomerID,
			&i.CustomerName,
			&i.ContactName,
			&i.Address,
			&i.City,
			&i.PostalCode,
			&i.Country,
			&i.OrderID,
			&i.OrderDate,
			&i.OrderDetailID,
			&i.ProductName,
			&i.Quantity,
			&i.Price,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteCustomer = `-- name: SoftDeleteCustomer :exec
UPDATE customer
SET
  deleted_at = ?
WHERE
  id = ?
`

type SoftDeleteCustomerParams struct {
	DeletedAt sql.NullTime
	ID        int32
}

func (q *Queries) SoftDeleteCustomer(ctx context.Context, arg SoftDeleteCustomerParams) error {
	_, err := q.db.ExecContext(ctx, softDeleteCustomer, arg.DeletedAt, arg.ID)
	return err
}

const updateCustomer = `-- name: UpdateCustomer :execresult
UPDATE customer
SET
  customer_name = ?,
  contact_name = ?,
  address = ?,
  city = ?,
  postal_code = ?,
  country = ?
WHERE
  id = ?
`

type UpdateCustomerParams struct {
	CustomerName sql.NullString
	ContactName  sql.NullString
	Address      sql.NullString
	City         sql.NullString
	PostalCode   sql.NullString
	Country      sql.NullString
	ID           int32
}

func (q *Queries) UpdateCustomer(ctx context.Context, arg UpdateCustomerParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateCustomer,
		arg.CustomerName,
		arg.ContactName,
		arg.Address,
		arg.City,
		arg.PostalCode,
		arg.Country,
		arg.ID,
	)
}
